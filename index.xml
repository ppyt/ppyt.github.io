<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>人生如青山，步步是风景</title><link>https://ppyt.github.io/</link><description>Recent content on 人生如青山，步步是风景</description><generator>Hugo -- 0.149.0</generator><language>zh-cn</language><lastBuildDate>Sun, 31 Aug 2025 00:59:18 +0800</lastBuildDate><atom:link href="https://ppyt.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>LLM/MLLM中的位置编码</title><link>https://ppyt.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link><pubDate>Sun, 31 Aug 2025 00:59:18 +0800</pubDate><guid>https://ppyt.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid><description>&lt;p&gt;位置编码是目前大模型所涉及到的基础概念之一，本文将从位置编码满足的条件，分析常见的两种编码方式：绝对位置编码和旋转位置编码，及其在多模态大模型中的直接拓展。&lt;/p&gt;
&lt;h3 id="位置编码需要满足的条件"&gt;位置编码需要满足的条件&lt;/h3&gt;
&lt;p&gt;位置编码的根本目的是为序列中的每个token引入位置信息，否则自注意力机制对序列是「无序」的。一个好的位置编码方法需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;唯一性&lt;/strong&gt;：每个位置有唯一表示，避免不同位置混淆。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可区分性&lt;/strong&gt;：相邻位置编码差异明显，模型能感知局部顺序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可组合性&lt;/strong&gt;：能有效表达位置间的相对关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;泛化性&lt;/strong&gt;：能处理比训练时更长的序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="二进制编码"&gt;二进制编码&lt;/h3&gt;
&lt;p&gt;其实，根据上面的条件，很容易想到的一个方案就是二进制编码。显而易见，二进制编码一定是唯一的。但是不具有可区分性，泛化性和可组合性。&lt;/p&gt;
&lt;h4 id="二进制编码的可区分性"&gt;二进制编码的可区分性&lt;/h4&gt;
&lt;p&gt;上面已经论述过，对于二进制编码，其是one-to-one的映射，每个位置都会有一个唯一的二进制串。因此在理论上，它不会出现两个位置相同的编码，完全满足可区分性。但在向量空间的相似性上，它并不理想：比如 7 = 0111 和 8 = 1000 的二进制差异非常大，汉明距离为4，实际上它们相邻，但编码却完全不相似。这意味着“局部邻近性”缺失，不利于捕捉局部顺序信息。&lt;/p&gt;
&lt;h4 id="二进制编码的可组合性"&gt;二进制编码的可组合性&lt;/h4&gt;
&lt;p&gt;在二进制编码中，位置差必须依赖模型学会“二进制到整数”的解码，再做减法。例如 0101 (5) 和 1000 (8)，模型需要先恢复数值才能得出差=3。&lt;/p&gt;
&lt;h4 id="二进制编码的泛化性"&gt;二进制编码的泛化性&lt;/h4&gt;
&lt;p&gt;训练时序列的最长长度为$L$，那把位置 $pos$ 转成二进制串所需的比特数为：
$$
\lceil \log_2(L) \rceil
$$&lt;/p&gt;
&lt;p&gt;比如，训练时最大序列长度为 256，那么会使用8位二进制。在测试时，假设位置 $=300$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;300 的二进制是 $100101100$，需要 9 位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但训练时 embedding 只有 8 维（每一位有一个 embedding），此时二进制编码体系不够用了。在训练长度之外会直接“溢出”，不能自然推广。&lt;/p&gt;
&lt;h3 id="绝对位置编码"&gt;绝对位置编码&lt;/h3&gt;
&lt;p&gt;$$PE_{(pos, 2i)} = \sin\left(\frac{pos}{10000^{2i/d_{model}}}\right)$$&lt;/p&gt;
&lt;p&gt;$$PE_{(pos, 2i+1)} = \cos\left(\frac{pos}{10000^{2i/d_{model}}}\right)$$&lt;/p&gt;
&lt;p&gt;$PE(pos) = [\sin(\omega_0 \cdot pos), \cos(\omega_0 \cdot pos), \sin(\omega_1 \cdot pos), \cos(\omega_1 \cdot pos), \dots, \sin(\omega_{d_{model}/2-1} \cdot pos), \cos(\omega_{d_{model}/2-1} \cdot pos)]$&lt;/p&gt;</description></item></channel></rss>